Стек - как пул памяти
=====================

Т.к. выражение-запрос не будет большим, а кол-во термов в нем фиксировано,
то кол-во аллокаций термов и связанных с ними доп. структур будет фиксировано
на протяжении всей программы. В таком случае можно сделать быструю аллокацию
при помощи стека - точно так же как Си аллоцирует авто переменные на стеке.
Этот модуль как раз и описывает такой стек:

     ___________
    |0|1|2|3|4|5|
    '-----------'
     |         |
    adr0      adr1

Как видно adr0 - это начало стека, его адрес, который соотв. адресу выделения
всей памяти под стек. А adr1 - это голова стека, указывает на своб. для
записи ячейку. При записи в нее значения, любого типа, adr1 сдвигается к adr0,
уменьшая тем самым размер стека. 5-ая ячейка на карт. свободна. Размер стека -
т.е. кол-во свободных ячеек равно в примере 6-ти. Обозначим ''адрес стека''
..:h-stkgetter как STKADR, кот. м. выразить как `((stkp)->attr)`, ..:xxx `xxx` где attr - это
имя поля, в данном случае adr0, а stkp - это указатель на структуру стека,
описывающую вышенарисованную схему стека. Ее ..:h-stkstr определение простое:

    typedef struct stk {
        void *adr0, *adr1;
    } stk_t, *stkp_t;

stk\_t - это алиас на тип самой структуры, а stkp_t - алиас на тип
указатель-на-структуру-стека.

STKADR - это просто getter, абстрагирующий нас от определения стека. М.
добавить и др., подобныe ему (STKTOP).

После описания типа стека (его стуктуры) и примитивных getter-ов, м.
рассмотреть более сложных утилитарные макросы. Так, размер стека (кол-во своб.
байт-ячеек) в примере равно 6. Формула ..:h-stksize вычисления проста - это:

    ((STKTOP(stkp) - (STKADR(stkp)) + 1)

т.е. вершина (5) - адрес (0) + 1 = 6.

вышеописанное вычисление размера (кол-во своб. байт) стека ..:h-stkfree :

    #define STKFREE(stkp) .._h-stksize

getter-ы ..:h-getters :

    #define STKADR(stkp) .._h-stkgetter
    #define STKTOP(stkp) .._h-stkgetter

инициализатор структуры стека ..:h-stkinit :

    #define EMPTYSTK {NULL, NULL}

Аллокация же ..:h-aloc на стеке будет проверять есть ли свободное пр-во и если
нет, то возвращать NULL, иначе - адрес свободной ячейки:

    #define STKALOC(stkp, sz) (STKFREE(stkp) >= (sz)? (STKTOP(stkp) -= (sz)) : NULL)

Также нам нужно декларировать ф-цию ..:h-stkroom, выделяющую первоначальное
пр-во (room) под все ячейки стека:

    int init_stk(stkp_t stk, uint32_t size)


Заголовочный файл
=================

Заголовочный файл модуля тогда будет ..>stk.h :

    #pragma once
    #include "pq.h"

    .._h-stkstr

	.._h-getters
	.._h-stkinit
	.._h-stkfree
	.._h-aloc
    .._h-stkroom;


Код модуля
==========

Наша ф-ция ..:c-stkinit инициализации стека (выделения пространства под стек):

    .._ h-stkroom {
        if (STKADR(stk)) {
            // if stack memory is allocated already, free it
            free(STKADR(stk));
            STKADR(stk) = STKTOP(stk) = NULL;
        }

        void *p = (void*)malloc(size);
        if (!p) return (1);
        else {
            STKADR(stk) = p;
            STKTOP(stk) = STKADR(stk) + size - 1;
            return (0);
        }
    }

Весь модуль ..>stk.c - это подключение заголовков и код:

    #include "stk.h"

    .._c-stkinit
